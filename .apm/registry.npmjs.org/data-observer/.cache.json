{"_id":"data-observer","_rev":"3-cf108898d817bc6265cdcffecae5ab13","name":"data-observer","description":"Unobtrusively observe essential application state.","dist-tags":{"latest":"0.0.3"},"versions":{"0.0.1":{"name":"data-observer","version":"0.0.1","description":"Unobtrusively observe essential application state.","main":"src/index.js","scripts":{"test":"gulp","build":"gulp build","coverage":"gulp coverage","prepublish":"npm run build"},"repository":{"type":"git","url":"https://github.com/nathansobo/data-observer.git"},"keywords":["observe es6 object data reactive relational algebra"],"author":{"name":"Nathan Sobo","email":"nathan@github.com"},"license":"MIT","bugs":{"url":"https://github.com/nathansobo/data-observer/issues"},"homepage":"https://github.com/nathansobo/data-observer","devDependencies":{"babel":"^5.0.0","chai":"^2.0.0","del":"^1.1.1","glob":"^5.0.12","gulp":"^3.8.10","gulp-babel":"^5.0.0","gulp-istanbul":"^0.6.0","gulp-jscs":"^1.4.0","gulp-jshint":"^1.9.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-notify":"^2.1.0","gulp-plumber":"^0.6.6","isparta":"^2.0.0","jshint-stylish":"^1.0.0","mkdirp":"^0.5.0","mocha":"^2.1.0","sinon":"^1.12.2","sinon-chai":"^2.7.0"},"nodeBoilerplateOptions":{"mochaGlobals":["stub","spy","expect"]},"dependencies":{"event-kit":"^1.1.0","random-seed":"^0.2.0"},"gitHead":"fce750ae7e180b89e6b21eada68d9fb77e8f59ee","_id":"data-observer@0.0.1","_shasum":"b78759ba103e304064e6d777a2fd7790f4fc8e45","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"nathansobo","email":"nathan@github.com"},"maintainers":[{"name":"nathansobo","email":"nathan@github.com"}],"dist":{"shasum":"b78759ba103e304064e6d777a2fd7790f4fc8e45","tarball":"http://registry.npmjs.org/data-observer/-/data-observer-0.0.1.tgz"},"directories":{}},"0.0.2":{"name":"data-observer","version":"0.0.2","description":"Unobtrusively observe essential application state.","main":"dist/index.js","scripts":{"test":"gulp","build":"gulp build","coverage":"gulp coverage","prepublish":"npm run build"},"repository":{"type":"git","url":"https://github.com/nathansobo/data-observer.git"},"keywords":["observe es6 object data reactive relational algebra"],"author":{"name":"Nathan Sobo","email":"nathan@github.com"},"license":"MIT","bugs":{"url":"https://github.com/nathansobo/data-observer/issues"},"homepage":"https://github.com/nathansobo/data-observer","devDependencies":{"babel":"^5.0.0","chai":"^2.0.0","del":"^1.1.1","glob":"^5.0.12","gulp":"^3.8.10","gulp-babel":"^5.0.0","gulp-istanbul":"^0.6.0","gulp-jscs":"^1.4.0","gulp-jshint":"^1.9.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-notify":"^2.1.0","gulp-plumber":"^0.6.6","isparta":"^2.0.0","jshint-stylish":"^1.0.0","mkdirp":"^0.5.0","mocha":"^2.1.0","sinon":"^1.12.2","sinon-chai":"^2.7.0"},"nodeBoilerplateOptions":{"mochaGlobals":["stub","spy","expect"]},"dependencies":{"event-kit":"^1.1.0","random-seed":"^0.2.0"},"gitHead":"7e05e1c134cb41ce8e06779a0ce110c2a8b2c75a","_id":"data-observer@0.0.2","_shasum":"6784abc7bd00c700e4e4cb335639791b5512a638","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"nathansobo","email":"nathan@github.com"},"maintainers":[{"name":"nathansobo","email":"nathan@github.com"}],"dist":{"shasum":"6784abc7bd00c700e4e4cb335639791b5512a638","tarball":"http://registry.npmjs.org/data-observer/-/data-observer-0.0.2.tgz"},"directories":{}},"0.0.3":{"name":"data-observer","version":"0.0.3","description":"Unobtrusively observe essential application state.","main":"dist/index.js","scripts":{"test":"gulp","build":"gulp build","coverage":"gulp coverage","prepublish":"npm run build"},"repository":{"type":"git","url":"https://github.com/nathansobo/data-observer.git"},"keywords":["observe es6 object data reactive relational algebra"],"author":{"name":"Nathan Sobo","email":"nathan@github.com"},"license":"MIT","bugs":{"url":"https://github.com/nathansobo/data-observer/issues"},"homepage":"https://github.com/nathansobo/data-observer","devDependencies":{"babel":"^5.0.0","chai":"^2.0.0","del":"^1.1.1","glob":"^5.0.12","gulp":"^3.8.10","gulp-babel":"^5.0.0","gulp-istanbul":"^0.6.0","gulp-jscs":"^1.4.0","gulp-jshint":"^1.9.0","gulp-load-plugins":"^0.8.0","gulp-mocha":"^2.0.0","gulp-notify":"^2.1.0","gulp-plumber":"^0.6.6","isparta":"^2.0.0","jshint-stylish":"^1.0.0","mkdirp":"^0.5.0","mocha":"^2.1.0","sinon":"^1.12.2","sinon-chai":"^2.7.0"},"nodeBoilerplateOptions":{"mochaGlobals":["stub","spy","expect"]},"dependencies":{"event-kit":"^1.1.0","random-seed":"^0.2.0"},"gitHead":"269a9d303bd3609fbe895b215266037a8b4813d9","_id":"data-observer@0.0.3","_shasum":"6b8aa8fd8788cf9fd13c77fa12b92e35f2b409d0","_from":".","_npmVersion":"2.5.1","_nodeVersion":"0.12.0","_npmUser":{"name":"nathansobo","email":"nathan@github.com"},"maintainers":[{"name":"nathansobo","email":"nathan@github.com"}],"dist":{"shasum":"6b8aa8fd8788cf9fd13c77fa12b92e35f2b409d0","tarball":"http://registry.npmjs.org/data-observer/-/data-observer-0.0.3.tgz"},"directories":{}}},"readme":"# data-observer\n[![Travis build status](http://img.shields.io/travis/nathansobo/data-observer.svg?style=flat)](https://travis-ci.org/nathansobo/data-observer)\n\nThis library wraps `Object.observe` and `Array.observe` to make them more usable. **Warning: This library has not yet been tested in production.**\n\n## Overview\n\n### Observing Objects\n\nTo observe an object, pass it to the `observe` function to return a *scalar observation*.\n\n```js\nimport observe from 'data-observer';\n\nlet object = {a: 1, b: 2, c: 3};\n\n// observe a property\nlet observation = observe(object, 'a')\nobservation.getValue(); // => 1\nobservation.onDidChangeValue((a) => { // called when `object.a` changes\n  console.log('a changed:', a)\n});\n\n// observe multiple properties\n// pass a function to combine them into a single value\nlet observation = observe(object, 'a', 'b', 'c', (a, b, c) => a + b + c)\nobservation.getValue(); // => 6\nobservation.onDidChangeValue((value) => { // called when `object.a`, `.b`, or `.c` change\n  console.log('a, b, or c changed:', value)\n});\n\n// observe the whole object\nlet observation = observe(object);\nobservation.getValue() // object\nlet disposable = observation.onDidChangeValue((object) => { // called when object changes\n  console.log('object changed', object);\n})\n```\n\n### Observing Arrays\n\nThis library is much better than the raw `Array.observe` API, because it efficiently coalesces the overlapping change events delivered by the raw API into a minimal list of non-overlapping changes. If you apply these changes to a copy of the original array in order, it will equal the current value of the observed array.\n\n```js\nlet array = ['a', 'b', 'c', 'd', 'e'];\nlet original = array.slice();\n\nobserve(array).onDidChangeValues(changes => { // called when array changes\n  for (let {index, removedCount, added} of changes) {\n    original.splice(index, removedCount, ...added);\n  }\n});\n```\n\n### Mapping Over Observations\n\nThe *observations* are returned from the `observe` function support a `map` operation, which maps a transformation function over the current value(s) of the observation. Here we map `value => value + 1` over an array observation.\n\n```js\nlet array = [1, 2, 3];\nlet observation = observe(array);\nlet mappedObservation = observation.map(value => value + 1);\nmappedObservation.getValues(); // => [2, 3, 4]\n```\n\nThe transform will also be applied to all `added` values passed to `onDidChangeValues` listeners.\n\nMapping over *scalar observations* is similar:\n\n```\nlet object = {a: 'hello'};\nlet observation = observe(object, 'a');\nlet mappedObservation = observation.map(value => value.toUpperCase());\nmappedObservation.getValue(); // => 'HELLO';\n```\n\nYou can chain calls to `map` if you're so inclined:\n\n```js\nlet doubleMapObservation =\n  observation.map(value => value + 1).map(value => value * 6);\n```\n\nYou can also apply a `map` operation by passing a transform function as the last argument to `observe`:\n\n```js\nlet observation = observe(array, value => value + 1);\n```\n\n\n## API\n\n### `observe(object, [...propertyNames], [transformFunction])`\n\nObserve an entire object or specific properties on an object.\n\n* `object` The object to observe.\n* `...propertyNames` The names of one or more properties to observe. If more than one property name is provided, you must supply a `transformFunction` to combine them.\n* `transformationFunction` An optional function taking one or more observed values as arguments that returns a single combined value for the observation. This argument is *required* if more than one property name is supplied.\n\nReturns a *scalar observation*.\n\n### `observe(array, [transformFunction])`\n\nObserve an array.\n\n* `array` The array to observe.\n* `transformFunction` An optional function transforming the values of the observed array.\n\nReturns an *array observation*.\n\n### Scalar Observations\n\nThese are returned when observing an object or an object's fields. Scalar observations represent a single value that changes over time.\n\n#### `getValue()`\n\nGet the current value of the observation.\n\n#### `onDidChangeValue(fn)`\n\nSubscribe to changes to the observation's value.\n\n* `fn` A function that will be called with the current value of the observation whenever it changes.\n\nReturns a `Disposable` on which `.dispose()` can be called to cancel the subscription.\n\n#### `map(transformFn)`\n\nBuild a new observation based on applying the given transform function to the this observation's value.\n\n* `transformFn` A function that transforms the observation's value.\n\nReturns a new *scalar observation*.\n\n### Array Observations\n\n#### `getValues()`\n\nGet the current values of the observed array.\n\n#### `onDidChangeValues(fn)`\n\nSubscribe to changes to the observed array. Applying the changes passed to the listener function to a copy of the array as it existed before being changed in order via `splice` should update the copy to match the current state of the array.\n\n* `fn` A function that will be called with an array of changes whenever the observed array changes.\n  * `changes` An `Array` of change objects with the following keys:\n    * `index` Where the change starts.\n    * `removedCount` The number of elements that were removed.\n    * `added` The elements that were added.\n\nReturns a `Disposable` on which `.dispose()` can be called to cancel the subscription.\n\n#### `map(transformFn)`\n\nBuild a new observation based on applying the given transform function to the this observation's values.\n\n* `transformFn` A function that transforms the observation's values.\n\nReturns a new *array observation*.\n\n## Rationale\n\nI built this library so I can use it from a view framework that I haven't finished writing yet. It will combine virtual-DOM diffing with data-model observation. Stay tuned.\n\n## Ideas\n\nArray observations could be extended with relational methods, such as `filter`, `join`, `flatMap`, etc. This would enable us to use the ideas of *functional relational programming* described in [Out of the Tarpit (PDF)][tarpit] while still using simple JavaScript primitives. Scalar observations could similarly be extended with an API reminiscent of [Rx][rx].\n\n[tarpit]: http://shaffner.us/cs/papers/tarpit.pdf\n[rx]: https://github.com/Reactive-Extensions/RxJS\n","maintainers":[{"name":"nathansobo","email":"nathan@github.com"}],"time":{"modified":"2015-07-13T19:16:19.946Z","created":"2015-07-13T18:23:40.137Z","0.0.1":"2015-07-13T18:23:40.137Z","0.0.2":"2015-07-13T18:25:27.278Z","0.0.3":"2015-07-13T19:16:19.946Z"},"homepage":"https://github.com/nathansobo/data-observer","keywords":["observe es6 object data reactive relational algebra"],"repository":{"type":"git","url":"https://github.com/nathansobo/data-observer.git"},"author":{"name":"Nathan Sobo","email":"nathan@github.com"},"bugs":{"url":"https://github.com/nathansobo/data-observer/issues"},"license":"MIT","readmeFilename":"README.md","_attachments":{},"_etag":"\"7JIL1CQ1I6DNMHGTFZ7QQW32J\""}